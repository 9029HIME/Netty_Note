# 粘包与Netty的Decoder

## 概述

对于Netty的使用，往往集中在TCP协议，TCP协议作为流式协议，无可避免会有粘包的问题。对于粘包问题，主流有以下几种解决方案：

1. 短连接：一个请求建立一个连接，太过笨重，不考虑。
2. 固定长度：将消息按照 固定长度 进行分割，对于不足的部分采取Padding补齐操作。这种方式比较简单，但浪费空间。
3. 分隔符：对消息进行读取，以 自定义分隔符 为界限，界定消息的完整性、独立性。空间使用率高，相对简单，就是分隔符作为内容的话需要转移，并且需要逐个逐个读取，效率偏低。
4. TLV：将消息以 Tag、Length、Value 的格式进行打包发送，接收者也按照 Tag、Lenght、Value 的方式进行解析。空间利用率、读取效率最高，但是开发成本也比较高，对于消息长度有 提前约定的限制，比较适用的方案。

对于Netty来说，数据解码和编码是通过Encoder、Decoder完成，对于上面的方案，Netty也有现成的类提供支持：

1. 固定长度：FixedLengthFrameDecoder，至于编码，在发消息的时候简单处理一下就好了。
2. 分隔符：DelimiterBasedFrameDecoder，至于编码，在发消息的时候简单处理一下就好了。
3. TLV：LengthFieldBasedFameDecoder、LengthFieldPrepender（Encoder）。

## ByteToMessageDecoder

不管使用哪种Decoder，都是继承自`ByteToMessageDecoder`。首先要明白：既然Netty需要解码，说明数据源自可读事件；既然是可读事件，Decoder最终是在Pipeline靠前的部分对数据进行读操作；既然是读操作，还是会回到channelRead方法里：

```java
// io.netty.handler.codec.ByteToMessageDecoder#channelRead
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    if (msg instanceof ByteBuf) {
        CodecOutputList out = CodecOutputList.newInstance();
        boolean var10 = false;
        try {
            var10 = true;
            ByteBuf data = (ByteBuf)msg;
            this.first = this.cumulation == null;
            if (this.first) {
                this.cumulation = data; // 如果是第一读，直接将数据扔给cumulation，它是Netty对SocketChannel可读数据的积累（后面会讲到）。
            } else {
                // 如果第n次读，则将数据追加到这个SocketChannel的cumulation里。
                this.cumulation = this.cumulator.cumulate(ctx.alloc(), this.cumulation, data);
            }
            this.callDecode(ctx, this.cumulation, out); // 实际的解码逻辑，交给对应的Decoder实现类处理。
            var10 = false;  
            // 省略
        }
        // 省略
    }
    // 省略
}


// io.netty.handler.codec.ByteToMessageDecoder#callDecode
protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        try {
            while(true) {
                if (in.isReadable()) {
                    int outSize = out.size();
                    if (outSize > 0) {
                        fireChannelRead(ctx, out, outSize);
                        out.clear();
                        if (ctx.isRemoved()) {
                            return;
                        }
                        outSize = 0;
                    }
                    int oldInputLength = in.readableBytes();
                    this.decodeRemovalReentryProtection(ctx, in, out); // 对cumulation的可读数据进行decode，decode完成后在cumulation清掉已读数据。
                    // 省略
                }
                return;
            }
        }
    	// 省略
    }
}


// io.netty.handler.codec.ByteToMessageDecoder#decodeRemovalReentryProtection
final void decodeRemovalReentryProtection(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        this.decodeState = 1;
        boolean var8 = false;

        try {
            var8 = true;
            this.decode(ctx, in, out); // 利用模板模式，调用具体实现类的decode方法，完成解码。
            var8 = false;
        } finally {
            if (var8) {
                boolean removePending = this.decodeState == 2;
                this.decodeState = 0;
                if (removePending) {
                    this.handlerRemoved(ctx);
                }

            }
        }

        boolean removePending = this.decodeState == 2;
        this.decodeState = 0;
        if (removePending) {
            this.handlerRemoved(ctx);
        }

    }
```